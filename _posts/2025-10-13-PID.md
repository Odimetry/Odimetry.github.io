---
layout: post
title: "PID Controller / PID 제어기"
date: 2025-10-13 13:05 +0900
tags: [test]
---
PID Controller
===
A proportional-integral-derivation controller (PID controller or three-term controller) is a feedback-based control loop mechanism commonly used to manage machines and processes that require continuous control and automatic adjustment. It is typically used in industrial control systems and various other applications where constant control through modulation is necessary without human intervention. The PID controller automatically compare the desired value (setpoint or SP) with the actual value of the system (process variable or PV). The difference between these two values is called the $error$ value, denoted as $e(t)$. [wikipedia](https://en.wikipedia.org/wiki/Proportional–integral–derivative_controller)

$$
\mathbf{MV(t)} = 
K_{p}e(t)
+ K_{i} \int_0^{t} e(t) dt
+ K_{d} \frac{de}{dt}
$$

Adaptation on microcontroller
===
When you use the microcontroller like Arduino(AVR), Raspberry pi, DSP or ARM boards, a PID controller is the most simple way for implementing feedback loop. For constructing feedback loop, all you need is microprocessor, plant(actuator), sensor(measurements). When you have the control obejctive, PID controller follows the algorithm:
1. First, controller moves the actuator(plant)
2. After that, measure the result of actuator through the sensor.
3. Calculate the error between objective and the measurements: $e = Obj - Measure$
4. Change errors with proportional, integrational, differential gains 
5. Apply the final error of time step into objective, and apply the actuator again.

Arduino pseudocode
===
```
const int T = 100;                  // Setup constraints
float error, error_old, error_inte; // Decare errors
float P, I, D;                      // Declare gains
float e, period;                    // Final error and period
float obejctives = 50;              // Declare objective

void setup(){ // Setup Initial conditions
    error_old = ##; // Setup old error
    error_inte = 0; // Integration of error
}

void loop(){  // Main loop
    period = T*1e-3;              // Declare period
    error = measure - obejctives; // Calculate error

    error_inte += error * period;              // Integration of error
    error_diff = (error - error_old) / period; // Difference of error

    e = (error * P) + (error_inte * I) + (error_diff * D) // Main formula

    digitalWrite(13, obejective + e); // Decide the main control

    error_old = error // Store the old error
    delay(T);         // Main loop period
}
```

Pros and Cons
===
The positive of a PID controller is "EASY" to make, and you can adapt this into diverse situations only in measuring the errors of every time steps. Also, to decide the gains of PID, Ziegler-Nichols method is a heuristic method of tuning a PID controller.\\
However, the negative of a PID controller is hard to predict objective's oscillation or rapidly changing(dynamic) situation. And the cost of actuator is not considered in main formula. These problems leds to Linear-quadratric(LQ) regulator.

PID 제어기
===
비례-적분-미분 제어기 또는 PID 제어기는 피드백(feedback-based) 제어기의 형태를 가지고 있으며 연속적인(continuous) 제어를 기반으로 한다. 이 제어기는 산업 현장과 더불어 다양한 상황에서 사용되며 사람의 개입없이 진동(modulation)을 제어하는데 사용된다. 제어하고자 하는 대상의 출력값(SP)을 측정하여 이를 원하고자 하는 참조값(설정값, PV)과 비교하여 오차를 계산하고, 이 오차값을 이용하여 제어에 필요한 제어값을 계산하는 구조로 되어있다.\\
표준적인 형태의 PID 제어기는 아래의 식과 같이 3개의 항을 더하여 제어값(MV: Manipulated Variable)을 계산하도록 구성이 되어있다. 이 항들은 각각 오차의 비례항, 적분항(integral), 미분항(derivative)이라 불린다.

$$
\mathbf{MV(t)} = 
K_{p}e(t)
+ K_{i} \int_0^{t} e(t) dt
+ K_{d} \frac{de}{dt}
$$

마이크로 컨트롤러에서의 적용
---
만약 아두이노(AVR), 라즈베리파이, DSP 혹은 ARM 보드와 같은 마이크로 컨트롤러를 가지고 있다면, PID 제어기는 피드백 경로(feedback loop)를 구성할 수 있는 가장 단순한 방법이다. 피드백 경로를 구성하기 위해선, 사용자가 필요한 것은 마이크로 컨트롤러, 플랜트(액추에이터, 혹은 모터), 센서(측정치)만 있으면 된다. 만약 사용자가 일련의 제어목적을 가지고 있다면 PID 제어기는 다음의 알고리즘으로 구현이 가능하다:

1. 가장 먼저, 제어기가 움직여야 한다.
2. 그 다음, 센서를 통해 액추에이터(모터)의 동작 결과를 측정한다.
3. 동작 목표와 측정치의 비교를 통해 에러(오류치)를 계산한다. $e(오류) = Obj(목표) - Measure(측정치)$
4. 에러(오류치)에 대해 비례, 적분, 미분 상수를 활용한 값을 각각 계산한다.
5. 특정 시간에 대한 최종 에러(오류치)를 계산하고, 이를 목표에 더하여 액추에이터를 움직인다.

아두이노 의사코드
===
```
const int T = 100;                  // 상수 선언
float error, error_old, error_inte; // 오류값 선언
float P, I, D;                      // 게인치(Gain) 선언
float e, period;                    // 최종 오류치와 주기 선언
float obejctives = 50;              // 목표치 선언

void setup(){ // 초기 상황 선언: 1번만 실행
    error_old = ##; // Setup old error
    error_inte = 0; // Integration of error
}

void loop(){  // 주 반복문: 주기적으로 동작함
    period = T*1e-3;              // 주기 선언
    error = measure - obejctives; // 에러(오류) 계산

    error_inte += error * period;              // 에러의 적분
    error_diff = (error - error_old) / period; // 에러의 차분(미분)

    e = (error * P) + (error_inte * I) + (error_diff * D) // 핵심 공식

    digitalWrite(13, obejective + e); // 최종 오류치와 목표로 액추에이터 제어

    error_old = error // 오류치를 옛 오류로 저장함
    delay(T);         // 주 반복문 주기 설정
}
```

장점과 단점
===
PID 제어기의 장점은 구현하기 "단순하다". 그리고 PID 제어기는 제어하는 시간에 대하여 에러(오류)를 측정할 수 있다면 다양한 상황에 적용할 수 있다. 이떄, PID 게인은 다양한 방법으로 결정될 수 있는데, 지글러-니콜스(Ziegler-Nichols method) 방법은 그 중 하나이다. \\
하지만, PID 제어기의 단점은 목표치가 진동을 하거나 빠르게 변화하는(동적) 상황에선 이를 구현할 수 없다. 또한 제어에 있어 액추에이터가 소모하는 비용은 수식에서 계산되지 않는다. 이러한 문제점들은 LQ(선형-이차) 제어를 불러온다.